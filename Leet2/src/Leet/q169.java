package Leet;

/*
 * O(n)的时间复杂度，O(1)的空间复杂度。
思路：数组中有一个数字的出现次数超过一半，也就是说这个数字的出现次数比其他的所有的数字的出现次数之和还要多。
因此我们可以考虑遍历数组的时候保存两个值，一个是数组中的数字，一个数次数。
当我们遍历到下一个数字的时候，如果下一个数字与我们之前保存的数字是相同的，那么次数加1，不同则减1,。
如果次数为0，那么我们需要保存下一个数字，并把次数设置为1,。
由于我们要找到的数字比其他的所有的数字的出现次数还要高，那么我们要找的数字一定是最后一次把次数设置为1时候所对应的数字。
 */

public class q169 {
	public int majorityElement(int[] nums) {
		int num=0,pre=nums[0];
		for(int i=1;i<nums.length;i++) {
			if(nums[i]==pre) {
				num++;
			}
			else {
				if(num==0) {
					pre=nums[i];
				}else {
					num--;
				}
			}
		}
		return pre;
    }
}
